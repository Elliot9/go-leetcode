# 703. 數據流中的第 K 大元素
#### 標籤：
- heap
- priority queue
- stream

## 題目：
設計一個找到數據流中第 K 大元素的類（class）。注意是排序後的第 K 大元素，不是第 K 個不同的元素。

實現 KthLargest 類：
- KthLargest(int k, int[] nums) 使用整數 k 和整數流 nums 初始化對象。
- int add(int val) 將 val 插入數據流 nums 後，返回當前數據流中第 K 大的元素。

## 可使用的方法：
- 最小堆（Min Heap）
- 優先隊列

## 解題思路： 
我們可以使用最小堆來解決這個問題。最小堆可以幫助我們高效地維護 K 個最大的元素。

詳細步驟如下：

1. 初始化：
   - 創建一個大小為 K 的最小堆。
   - 遍歷初始數組 nums，將元素添加到堆中。
   - 如果堆的大小超過 K，則移除堆頂元素（最小的元素）。

2. Add 操作：
   - 如果堆的大小小於 K，直接將新元素添加到堆中。
   - 如果堆的大小等於 K：
     - 如果新元素大於堆頂元素，則移除堆頂元素，並將新元素添加到堆中。
     - 否則，忽略新元素。
   - 返回堆頂元素，它就是第 K 大的元素。

實現細節：
- 我們使用一個切片來模擬最小堆。
- 堆的第一個元素（索引 0）是一個哨兵，不參與實際計算。
- 實際的堆元素從索引 1 開始。

時間複雜度：
- 構造函數：O(N log K)，其中 N 是初始數組的長度。
- Add 操作：O(log K)

空間複雜度：O(K)，用於存儲堆中的 K 個元素。

這種方法的優點是可以高效地處理數據流，每次 Add 操作的時間複雜度都是 O(log K)，而不是對整個數據流進行排序。

注意：在實際實現中，我們需要小心處理邊界情況，例如初始數組的長度小於 K 的情況。
