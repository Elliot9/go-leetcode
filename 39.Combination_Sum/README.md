# 39. 組合總和
#### 標籤：
- recursion
- backtracking
- dfs

## 題目：
給你一個 無重複元素 的整數數組 candidates 和一個目標整數 target ，找出 candidates 中可以使數字和為目標數 target 的 所有 不同組合 ，並以列表形式返回。你可以按 任意順序 返回這些組合。

candidates 中的 同一個 數字可以 無限制重複被選取 。如果至少一個數字的被選數量不同，則兩種組合是不同的。 

對於給定的輸入，保證和為 target 的不同組合數少於 150 個。

## 可使用的方法：
- 回溯法（DFS）

## 解題思路： 
我們將使用回溯法（DFS）來解決這個問題。這種方法的核心思想是通過遞歸來構建所有可能的組合。

詳細步驟如下：

1. 定義一個結果數組 `result` 來存儲所有有效的組合，以及一個臨時數組 `current` 來構建當前的組合。

2. 定義一個遞歸函數 `dfs(result, combination, target, startIndex)`：
   - 如果 target 小於 0，直接返回（當前組合和超過目標值）。
   - 如果 target 等於 0，將當前組合加入結果數組（找到一個有效組合）。
   - 從 startIndex 開始遍歷 candidates 數組：
     a. 將當前數字加入組合。
     b. 遞歸調用 dfs 函數，更新 target 和 startIndex。
     c. 回溯：將最後加入的數字從組合中移除。

3. 調用 dfs 函數，初始 startIndex 為 0。

4. 返回 `result` 作為最終結果。

這種方法的關鍵在於使用 startIndex 來避免重複組合，同時允許重複使用相同的數字。

時間複雜度：O(N^(T/M + 1))，其中 N 是 candidates 數組的長度，T 是目標值，M 是 candidates 中的最小值。這是一個粗略的上界，實際複雜度可能更低。

空間複雜度：O(T/M)，這是由於遞歸調用棧的開銷。最壞情況下，遞歸深度為 T/M。

注意：這個問題的解空間可能很大，但題目保證解的數量少於 150 個，這有助於控制時間複雜度。
